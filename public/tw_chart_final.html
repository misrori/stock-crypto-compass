<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Goldhand Terminal (Fixed Logo)</title>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    /* ALAPOK */
    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background-color: #ffffff; 
      color: #333;
    }
    
    .app-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* TOOLBAR */
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      align-items: center;
      background: #f8f9fa;
      padding: 8px 15px;
      border-bottom: 1px solid #e0e0e0;
      flex-shrink: 0;
      z-index: 50;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }

    .group {
      display: flex;
      align-items: center;
      gap: 5px;
      padding-right: 15px;
      border-right: 1px solid #ddd;
    }
    .group:last-child { border-right: none; }
    
    .label { font-size: 10px; color: #888; font-weight: 700; margin-right: 5px; letter-spacing: 0.5px; }

    /* VEZÉRLŐK */
    select {
      background: #fff;
      color: #333;
      border: 1px solid #ccc;
      padding: 4px 8px;
      border-radius: 4px;
      outline: none;
      cursor: pointer;
      font-size: 12px;
    }

    button {
      background: transparent;
      color: #555;
      border: 1px solid transparent;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s;
    }
    button:hover { background: #e9ecef; color: #000; }
    button.active { background: #2962ff; color: #fff; }
    button.toggle-on { color: #2962ff; background: rgba(41, 98, 255, 0.1); border: 1px solid rgba(41, 98, 255, 0.3); }
    
    button.gold-btn.toggle-on { 
        color: #d8a000; 
        background: rgba(255, 192, 0, 0.15); 
        border: 1px solid rgba(255, 192, 0, 0.5);
    }

    /* CHART WRAPPER (Most már csak fehér, nincs kép) */
    .chart-wrapper {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      background-color: #ffffff; 
    }

    /* MAIN CHART - ITT VAN A HÁTTÉRKÉP */
    .main-chart { 
        flex-grow: 1; 
        width: 100%; 
        min-height: 0; 
        z-index: 2; 
        position: relative;
        
        /* HÁTTÉRKÉP BEÁLLÍTÁSOK KIZÁRÓLAG ITT */
        background-image: url('https://i.ibb.co/TMdGbqfK/hattergh.png');
        background-repeat: no-repeat;
        background-position: center center; /* Mindig a DIV közepén */
        background-size: auto; /* Eredeti méret */
    }
    
    /* Indicator Charts (Nincs háttérkép) */
    .indicator-chart { 
        height: 140px; 
        width: 100%; 
        border-top: 1px solid #e0e0e0; 
        flex-shrink: 0; 
        z-index: 2; 
        background: #ffffff; 
    }
    
    .loading {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255,255,255,0.9);
      display: flex; justify-content: center; align-items: center;
      z-index: 100; font-size: 14px; color: #333; letter-spacing: 1px;
    }

    /* VPVR */
    .vp-container {
        position: absolute;
        top: 0;
        right: 60px;
        width: 160px;
        height: 100%;
        pointer-events: none;
        z-index: 1;
        opacity: 0.95; 
        display: flex;
        flex-direction: column;
    }
    .vp-bar {
        position: absolute;
        right: 0;
        height: 3px; 
        background: rgba(21, 101, 192, 0.65); 
        border-left: 1px solid rgba(255,255,255,0.5);
        transition: width 0.2s ease-out;
        margin-bottom: 1px;
    }
    .vp-poc { 
        background: rgba(255, 61, 0, 0.85) !important; 
        border-left: 1px solid rgba(255, 61, 0, 1);
        z-index: 5;
    }

  </style>
</head>
<body>

  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;
    const { createChart, LineStyle, CrosshairMode, ColorType } = LightweightCharts;

    // --- MATH ---
    const calculateSMA = (data, period) => {
      const result = [];
      for (let i = 0; i < data.length; i++) {
        if (i < period - 1) { result.push({ time: data[i].time, value: NaN }); continue; }
        let sum = 0;
        for (let j = 0; j < period; j++) sum += data[i - j].close;
        result.push({ time: data[i].time, value: sum / period });
      }
      return result;
    };

    const calculateRSI = (data, period = 14) => {
      const result = [];
      let avgGain = 0, avgLoss = 0;
      for (let i = 1; i < data.length; i++) {
        const change = data[i].close - data[i - 1].close;
        const gain = change > 0 ? change : 0;
        const loss = change < 0 ? Math.abs(change) : 0;
        if (i <= period) {
          avgGain += gain; avgLoss += loss;
          if (i === period) {
            avgGain /= period; avgLoss /= period;
            result.push({ time: data[i].time, value: 100 - 100 / (1 + (avgGain/avgLoss)) });
          } else { result.push({ time: data[i].time, value: NaN }); }
        } else {
          avgGain = (avgGain * (period - 1) + gain) / period;
          avgLoss = (avgLoss * (period - 1) + loss) / period;
          result.push({ time: data[i].time, value: 100 - 100 / (1 + (avgGain/avgLoss)) });
        }
      }
      return result;
    };

    const calculateMACD = (data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) => {
        const getEMA = (values, period) => {
            const result = new Array(values.length).fill(NaN);
            let firstValidIdx = -1;
            for(let i=0; i<values.length; i++) { if(!isNaN(values[i])) { firstValidIdx = i; break; } }
            if (firstValidIdx === -1 || values.length - firstValidIdx < period) return result;

            let sum = 0;
            for(let i=firstValidIdx; i < firstValidIdx + period; i++) sum += values[i];
            let ema = sum / period;
            result[firstValidIdx + period - 1] = ema;

            const k = 2 / (period + 1);
            for(let i=firstValidIdx + period; i < values.length; i++) {
                if(isNaN(values[i])) { result[i] = NaN; } 
                else { ema = (values[i] - ema) * k + ema; result[i] = ema; }
            }
            return result;
        };

        const closes = data.map(d => d.close);
        const fastEMA = getEMA(closes, fastPeriod);
        const slowEMA = getEMA(closes, slowPeriod);
        const macdLine = [];
        const macdSeriesData = [];
        const signalSeriesData = [];
        const histSeriesData = [];

        for(let i=0; i<data.length; i++) {
            let val = NaN;
            if(!isNaN(fastEMA[i]) && !isNaN(slowEMA[i])) { val = fastEMA[i] - slowEMA[i]; }
            macdLine.push(val);
        }

        const signalLine = getEMA(macdLine, signalPeriod);

        for(let i=0; i<data.length; i++) {
            const time = data[i].time;
            const macd = macdLine[i];
            const sig = signalLine[i];
            let hist = NaN;
            let histColor = '#26a69a'; 

            if (!isNaN(macd) && !isNaN(sig)) {
                hist = macd - sig;
                histColor = hist >= 0 ? '#26a69a' : '#ef5350';
            }
            macdSeriesData.push({ time, value: macd });
            signalSeriesData.push({ time, value: sig });
            histSeriesData.push({ time, value: hist, color: histColor });
        }
        return { macdSeriesData, signalSeriesData, histSeriesData };
    };

    const calculateSMMA = (values, length) => {
        const smma = new Array(values.length).fill(NaN);
        let sum = 0;
        for(let i = 0; i < length; i++) sum += values[i];
        smma[length-1] = sum / length;
        for(let i = length; i < values.length; i++) {
            smma[i] = (smma[i-1] * (length - 1) + values[i]) / length;
        }
        return smma;
    };

    const calculateGoldhand = (candles) => {
        const hl2 = candles.map(c => (c.high + c.low) / 2);
        const v1 = calculateSMMA(hl2, 15);
        const v2 = calculateSMMA(hl2, 19);
        const v3 = calculateSMMA(hl2, 25);
        const v4 = calculateSMMA(hl2, 29);

        const line1Data = []; const line2Data = []; const fillData = [];  

        for(let i = 0; i < candles.length; i++) {
            if(isNaN(v4[i])) continue;
            const val1 = v1[i]; const val2 = v2[i]; const val3 = v3[i]; const val4 = v4[i]; 
            const bullish = (val1 > val2) && (val2 > val3) && (val3 > val4);
            const bearish = (val1 < val2) && (val2 < val3) && (val3 < val4);
            
            let lineColor = '#999'; let fillColor = 'rgba(200, 200, 200, 0.2)'; 
            if (bullish) { lineColor = '#F57F17'; fillColor = 'rgba(255, 192, 0, 0.3)'; }
            if (bearish) { lineColor = '#1565C0'; fillColor = 'rgba(21, 101, 192, 0.3)'; }

            const time = candles[i].time;
            line1Data.push({ time: time, value: val1, color: lineColor });
            line2Data.push({ time: time, value: val4, color: lineColor });
            fillData.push({ time: time, open: val1, high: Math.max(val1, val4), low: Math.min(val1, val4), close: val4, color: fillColor });
        }
        return { line1Data, line2Data, fillData };
    };

    // --- APP ---

    const App = () => {
      const [symbol, setSymbol] = useState('AAPL');
      const [interval, setInterval] = useState('1d');
      const [loading, setLoading] = useState(false);
      
      const [showSMA, setShowSMA] = useState(true);
      const [showRSI, setShowRSI] = useState(true);
      const [showGold, setShowGold] = useState(true);
      const [showVol, setShowVol] = useState(true);
      const [showVP, setShowVP] = useState(true);
      const [showMACD, setShowMACD] = useState(true);
      
      const [vpElements, setVpElements] = useState([]);
      
      const mainRef = useRef(null);
      const rsiRef = useRef(null);
      const macdRef = useRef(null); 

      const chart = useRef(null);
      const rsiChart = useRef(null);
      const macdChart = useRef(null); 
      
      const candleSeries = useRef(null);
      const volumeSeries = useRef(null);
      const sma50 = useRef(null);
      const sma200 = useRef(null);
      const goldFillSeries = useRef(null);
      const gold1 = useRef(null);
      const gold2 = useRef(null);
      
      const rsiLine = useRef(null);
      
      const macdHistSeries = useRef(null);
      const macdLineSeries = useRef(null);
      const signalLineSeries = useRef(null);

      const allDataRef = useRef([]);

      // 1. CHART INIT
      useEffect(() => {
        // MAIN CHART - ÁTLÁTSZÓ HÁTTÉR, hogy a CSS háttérkép látszódjon
        chart.current = createChart(mainRef.current, {
          layout: { background: { type: ColorType.Solid, color: 'transparent' }, textColor: '#191919' },
          grid: { vertLines: { color: '#e1e1e1' }, horzLines: { color: '#e1e1e1' } },
          width: mainRef.current.clientWidth,
          height: 450,
          crosshair: { mode: CrosshairMode.Normal },
          timeScale: { borderColor: '#ccc', timeVisible: true },
          rightPriceScale: { borderColor: '#ccc' }
        });

        volumeSeries.current = chart.current.addHistogramSeries({
            color: '#26a69a',
            priceFormat: { type: 'volume' },
            priceScaleId: '',
            scaleMargins: { top: 0.8, bottom: 0 },
        });

        goldFillSeries.current = chart.current.addBarSeries({ thinBars: false, openVisible: false, downColor: 'transparent', upColor: 'transparent' });
        candleSeries.current = chart.current.addCandlestickSeries({ upColor: '#00796b', downColor: '#d32f2f', borderVisible: false, wickUpColor: '#00796b', wickDownColor: '#d32f2f' });
        sma50.current = chart.current.addLineSeries({ color: '#2962ff', lineWidth: 1, title: 'SMA 50' });
        sma200.current = chart.current.addLineSeries({ color: '#ff6d00', lineWidth: 1, title: 'SMA 200' });
        gold1.current = chart.current.addLineSeries({ lineWidth: 2, title: 'Gold High' });
        gold2.current = chart.current.addLineSeries({ lineWidth: 2, title: 'Gold Low' });

        // RSI (Fehér háttér, nincs kép)
        rsiChart.current = createChart(rsiRef.current, {
          layout: { background: { type: ColorType.Solid, color: '#ffffff' }, textColor: '#191919' },
          grid: { vertLines: { color: '#f0f0f0' }, horzLines: { color: '#f0f0f0' } },
          width: rsiRef.current.clientWidth,
          height: 140,
          timeScale: { visible: false },
          crosshair: { mode: CrosshairMode.Normal },
        });
        rsiLine.current = rsiChart.current.addLineSeries({ color: '#7b1fa2', lineWidth: 2 });
        rsiLine.current.createPriceLine({ price: 70, color: '#888', lineWidth: 1, lineStyle: LineStyle.Dashed });
        rsiLine.current.createPriceLine({ price: 30, color: '#888', lineWidth: 1, lineStyle: LineStyle.Dashed });

        // MACD (Fehér háttér, nincs kép)
        macdChart.current = createChart(macdRef.current, {
          layout: { background: { type: ColorType.Solid, color: '#ffffff' }, textColor: '#191919' },
          grid: { vertLines: { color: '#f0f0f0' }, horzLines: { color: '#f0f0f0' } },
          width: macdRef.current.clientWidth,
          height: 140,
          timeScale: { visible: false },
          crosshair: { mode: CrosshairMode.Normal },
        });
        macdHistSeries.current = macdChart.current.addHistogramSeries({ color: '#26a69a' });
        macdLineSeries.current = macdChart.current.addLineSeries({ color: '#2962FF', lineWidth: 2, title: 'MACD' });
        signalLineSeries.current = macdChart.current.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: 'Signal' });


        // --- SYNC LOGIC ---
        const charts = [
            { chart: chart.current, series: candleSeries.current }, 
            { chart: rsiChart.current, series: rsiLine.current }, 
            { chart: macdChart.current, series: macdLineSeries.current }
        ];

        charts.forEach(c => {
            c.chart.timeScale().subscribeVisibleLogicalRangeChange(range => {
                if (range) {
                    charts.forEach(other => {
                        if (other.chart !== c.chart) {
                            other.chart.timeScale().setVisibleLogicalRange(range);
                        }
                    });
                    if (c.chart === chart.current) updateVolumeProfile();
                }
            });
        });

        charts.forEach(c => {
            c.chart.subscribeCrosshairMove(param => {
                if (!param.time || param.point === undefined) {
                    charts.forEach(other => {
                         if (other.chart !== c.chart) other.chart.clearCrosshairPosition();
                    });
                    return;
                }
                charts.forEach(other => {
                    if (other.chart !== c.chart) {
                        other.chart.setCrosshairPosition(0, param.time, other.series); 
                    }
                });
            });
        });

        const handleResize = () => {
          if(chart.current) chart.current.applyOptions({ width: mainRef.current.clientWidth });
          if(rsiChart.current) rsiChart.current.applyOptions({ width: rsiRef.current.clientWidth });
          if(macdChart.current) macdChart.current.applyOptions({ width: macdRef.current.clientWidth });
          updateVolumeProfile();
        };
        window.addEventListener('resize', handleResize);
        
        return () => {
            window.removeEventListener('resize', handleResize);
            chart.current.remove();
            rsiChart.current.remove();
            macdChart.current.remove();
        }
      }, []);

      // --- VOLUME PROFILE ---
      const updateVolumeProfile = useCallback(() => {
          if (!chart.current || !candleSeries.current || !showVP || allDataRef.current.length === 0) {
              setVpElements([]);
              return;
          }

          const visibleRange = chart.current.timeScale().getVisibleLogicalRange();
          if (!visibleRange) return;

          const startIdx = Math.max(0, Math.floor(visibleRange.from));
          const endIdx = Math.min(allDataRef.current.length - 1, Math.ceil(visibleRange.to));
          
          const visibleData = [];
          for(let i = startIdx; i <= endIdx; i++) {
              if (allDataRef.current[i]) visibleData.push(allDataRef.current[i]);
          }

          if (visibleData.length === 0) return;

          let minPrice = Infinity; let maxPrice = -Infinity;
          visibleData.forEach(d => { if (d.low < minPrice) minPrice = d.low; if (d.high > maxPrice) maxPrice = d.high; });

          const numBins = 40;
          const binSize = (maxPrice - minPrice) / numBins;
          if (binSize === 0) return;

          const bins = new Array(numBins).fill(0);
          visibleData.forEach(d => {
              const binIdx = Math.floor((d.close - minPrice) / binSize);
              if (binIdx >= 0 && binIdx < numBins) bins[binIdx] += d.volume;
          });

          const maxVol = Math.max(...bins);
          const elements = [];
          const series = candleSeries.current;

          for(let i = 0; i < numBins; i++) {
              if (bins[i] === 0) continue;
              const priceLevel = minPrice + (i * binSize) + (binSize / 2);
              const coordinate = series.priceToCoordinate(priceLevel);
              if (coordinate === null || coordinate < 0 || coordinate > 500) continue;
              const widthPct = (bins[i] / maxVol) * 100;
              const isPOC = bins[i] === maxVol;
              let barColor = isPOC ? 'rgba(255, 61, 0, 0.85)' : 'rgba(21, 101, 192, 0.65)'; 
              elements.push(
                  <div key={i} className={`vp-bar ${isPOC ? 'vp-poc' : ''}`} style={{ top: coordinate - 2, width: `${widthPct}%`, backgroundColor: barColor }} />
              );
          }
          setVpElements(elements);
      }, [showVP]);

      // 2. DATA
      useEffect(() => {
        setLoading(true);
        const range = '10y'; 
        const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=${interval}&range=${range}`;
        const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(yahooUrl);

        fetch(proxyUrl)
          .then(res => res.json())
          .then(data => {
            const result = data.chart.result[0];
            const quotes = result.indicators.quote[0];
            const timestamps = result.timestamp;

            const candles = [];
            const volumes = [];
            
            for (let i = 0; i < timestamps.length; i++) {
              if (quotes.open[i] === null) continue;
              const c = { time: timestamps[i], open: quotes.open[i], high: quotes.high[i], low: quotes.low[i], close: quotes.close[i], volume: quotes.volume[i] || 0 };
              candles.push(c);
              const color = quotes.close[i] >= quotes.open[i] ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)';
              volumes.push({ time: timestamps[i], value: quotes.volume[i], color: color });
            }

            allDataRef.current = candles;

            candleSeries.current.setData(candles);
            volumeSeries.current.setData(volumes);
            
            sma50.current.setData(calculateSMA(candles, 50));
            sma200.current.setData(calculateSMA(candles, 200));
            rsiLine.current.setData(calculateRSI(candles));
            
            const macdData = calculateMACD(candles);
            macdLineSeries.current.setData(macdData.macdSeriesData);
            signalLineSeries.current.setData(macdData.signalSeriesData);
            macdHistSeries.current.setData(macdData.histSeriesData);
            
            const { line1Data, line2Data, fillData } = calculateGoldhand(candles);
            gold1.current.setData(line1Data);
            gold2.current.setData(line2Data);
            goldFillSeries.current.setData(fillData);

            setLoading(false);
            setTimeout(updateVolumeProfile, 500);
          })
          .catch(e => { console.error(e); setLoading(false); });
      }, [symbol, interval, updateVolumeProfile]);

      // VISIBILITY
      useEffect(() => { if(sma50.current) { sma50.current.applyOptions({ visible: showSMA }); sma200.current.applyOptions({ visible: showSMA }); } }, [showSMA]);
      useEffect(() => { if(gold1.current) { gold1.current.applyOptions({ visible: showGold }); gold2.current.applyOptions({ visible: showGold }); goldFillSeries.current.applyOptions({ visible: showGold }); } }, [showGold]);
      useEffect(() => { if(volumeSeries.current) volumeSeries.current.applyOptions({ visible: showVol }); }, [showVol]);
      useEffect(() => { updateVolumeProfile(); }, [showVP, updateVolumeProfile]);

      return (
        <div className="app-container">
          <div className="toolbar">
            <div className="group">
              <span className="label">ASSET</span>
              <select value={symbol} onChange={e => setSymbol(e.target.value)}>
                <option value="AAPL">AAPL</option>
                <option value="TSLA">TSLA</option>
                <option value="MSFT">MSFT</option>
                <option value="AMZN">AMZN</option>
                <option value="NVDA">NVDA</option>
                <option value="BTC-USD">BTC</option>
                <option value="ETH-USD">ETH</option>
              </select>
            </div>
            <div className="group">
              <span className="label">TF</span>
              <button className={interval === '1d' ? 'active' : ''} onClick={() => setInterval('1d')}>1D</button>
              <button className={interval === '1wk' ? 'active' : ''} onClick={() => setInterval('1wk')}>1W</button>
            </div>
            <div className="group">
              <span className="label">IND</span>
              <button className={showSMA ? 'toggle-on' : ''} onClick={() => setShowSMA(!showSMA)}>SMA</button>
              <button className={`gold-btn ${showGold ? 'toggle-on' : ''}`} onClick={() => setShowGold(!showGold)}>GOLDHAND</button>
              <button className={showRSI ? 'toggle-on' : ''} onClick={() => setShowRSI(!showRSI)}>RSI</button>
              <button className={showMACD ? 'toggle-on' : ''} onClick={() => setShowMACD(!showMACD)}>MACD</button>
              <button className={showVol ? 'toggle-on' : ''} onClick={() => setShowVol(!showVol)}>VOL</button>
              <button className={showVP ? 'toggle-on' : ''} onClick={() => setShowVP(!showVP)} title="Volume Profile">VPVR</button>
            </div>
            <div style={{marginLeft: 'auto', fontSize:'11px', color:'#888'}}>
                Goldhand Terminal (Fixed Logo)
            </div>
          </div>
          
          <div className="chart-wrapper">
             {loading && <div className="loading">LOADING...</div>}
             {showVP && <div className="vp-container">{vpElements}</div>}
             
             <div ref={mainRef} className="main-chart" />
             <div ref={rsiRef} className="indicator-chart" style={{ display: showRSI ? 'block' : 'none' }} />
             <div ref={macdRef} className="indicator-chart" style={{ display: showMACD ? 'block' : 'none' }} />
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>